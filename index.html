<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rıfat Emrehan Ayhan – Portfolio</title>
    <link rel="stylesheet" href="https://fonts.cdnfonts.com/css/sf-pro-display">
    <style>
        :root {
            --white: #ffffff;
            --accent-blue: #94b3ff;
            --glow-color: rgba(148, 179, 255, 0.9);
        }
        html, body {
            margin: 0; padding: 0; width: 100vw; min-height: 100vh;
            overflow-x: hidden; background-color: transparent;
            font-family: 'SF Pro Display', sans-serif; color: #F4F6FA;
        }
        #bg-canvas {
            position: fixed; inset: 0; z-index: -2;
            background: radial-gradient(ellipse at 40% 50%, #08090f 0%, #040408 60%, #020204 100%);
            pointer-events: none;
        }
        .page-section {
            position: absolute; top: 0; left: 0; width: 100%; min-height: 100vh;
            padding-bottom: 100px; box-sizing: border-box;
            transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.6s ease;
            opacity: 0; pointer-events: none;
        }
        #home { opacity: 1; pointer-events: all; transform: translateX(0); display: flex; flex-direction: column; align-items: center; }
        #home.slide-out-right { transform: translateX(100%); opacity: 0; }
        #home.slide-out-left  { transform: translateX(-100%); opacity: 0; }
        #videos { transform: translateX(-100%); }
        #images { transform: translateX(100%); }
        .page-section.active { opacity: 1; pointer-events: all; transform: translateX(0) !important; z-index: 20; }

        .hero { text-align: center; padding-top: 100px; pointer-events: none; }
        .hero h1 { font-size: 48px; font-weight: 600; margin: 0; color: var(--white); letter-spacing: 2px; }
        .hero h2 { font-size: 22px; font-weight: 300; opacity: 0.7; margin-top: 12px; letter-spacing: 1px; }

        .section-boxes { display: flex; justify-content: center; gap: 40px; margin-top: 80px; }
        .big-box {
            background: rgba(255,255,255,0.07);
            backdrop-filter: blur(24px) saturate(160%);
            -webkit-backdrop-filter: blur(24px) saturate(160%);
            padding: 55px 85px; border-radius: 20px; font-size: 28px;
            border: 1px solid rgba(255,255,255,0.18); color: var(--white);
            cursor: pointer; transition: 0.35s ease;
            box-shadow: 0 8px 32px rgba(0,0,0,0.35),
                        inset 0 1px 0 rgba(255,255,255,0.15),
                        inset 0 -1px 0 rgba(255,255,255,0.05);
        }
        .big-box:hover {
            background: rgba(255,255,255,0.18);
            border-color: rgba(255,255,255,0.35);
            box-shadow: 0 12px 48px rgba(148,179,255,0.2),
                        inset 0 1px 0 rgba(255,255,255,0.25);
            transform: translateY(-5px);
        }

        .back-btn { font-size: 16px; margin: 40px 0 20px 8%; display: inline-block; background: rgba(255,255,255,0.07); padding: 10px 25px; border-radius: 30px; cursor: pointer; transition: 0.3s; border: 1px solid rgba(255,255,255,0.1); }
        .back-btn:hover { background: var(--white); color: #000; }
        h1.section-title { padding-left: 8%; margin-bottom: 30px; }

        .grid-layout { display: grid; gap: 20px; max-width: 1400px; margin: 0 auto; padding: 0 20px; box-sizing: border-box; }
        .video-grid, .image-grid { grid-template-columns: repeat(5, 1fr); }
        .item-wrapper {
            position: relative; width: 100%; height: 0; border-radius: 12px; overflow: hidden; cursor: pointer;
            background: #0d0d12; border: 1px solid rgba(255,255,255,0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
        }
        .video-item  { padding-bottom: 125%; }
        .image-item  { padding-bottom: 56.25%; }
        .main-thumbnail { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transition: transform 0.5s ease; }
        .item-wrapper:hover { transform: scale(1.04); border-color: rgba(255,255,255,0.45); box-shadow: 0 0 40px rgba(200,215,255,0.12); z-index: 5; }
        .item-wrapper:hover .main-thumbnail { transform: scale(1.1); }

        .screenshot-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; max-width: 1400px; margin: 0 auto; padding-bottom: 50px; }
        .screenshot-item { position: relative; width: 100%; padding-bottom: 63.1%; border-radius: 12px; overflow: hidden; border: 1px solid rgba(255,255,255,0.08); transition: 0.3s; cursor: pointer; }
        .screenshot-item img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        .screenshot-item:hover { border-color: rgba(255,255,255,0.35); box-shadow: 0 0 40px rgba(200,215,255,0.1); transform: scale(1.02); }

        #content-modal {
            display: none; position: fixed; inset: 0; background-color: rgba(0,0,0,0.85);
            z-index: 10000; align-items: center; justify-content: center; backdrop-filter: blur(30px);
        }
        .modal-wrapper { position: relative; display: inline-block; max-width: 90vw; max-height: 85vh; line-height: 0; }
        #modal-content-container { position: relative; display: block; }
        #modal-content-container img, #modal-content-container iframe {
            max-width: 90vw; max-height: 85vh; border-radius: 8px; display: block;
            box-shadow: 0 0 60px rgba(0,0,0,0.9); border: 1px solid rgba(255,255,255,0.12);
        }
        .close-btn {
            position: absolute; top: -18px; right: -18px; width: 36px; height: 36px;
            background: var(--white); color: #000; border-radius: 50%; display: flex;
            align-items: center; justify-content: center; cursor: pointer; z-index: 10010;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); transition: 0.2s;
        }
        .close-btn svg { width: 18px; height: 18px; stroke: currentColor; stroke-width: 3; pointer-events: none; }
        .close-btn:hover { transform: scale(1.15); background: var(--accent-blue); }

        @media (max-width: 1024px) {
            .video-grid, .image-grid { grid-template-columns: repeat(3, 1fr); }
            .screenshot-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
<canvas id="bg-canvas"></canvas>

<div id="content-modal" onclick="closeModal()">
    <div class="modal-wrapper" onclick="event.stopPropagation()">
        <div class="close-btn" onclick="closeModal()">
            <svg viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </div>
        <div id="modal-content-container"></div>
    </div>
</div>

<div id="home" class="page-section">
    <div class="hero">
        <h1>Rıfat Emrehan Ayhan</h1>
        <h2>Video Editörü • Kurgu & Montaj • İçerik Üreticisi</h2>
    </div>
    <div class="section-boxes">
        <div class="big-box" onclick="goToVideos()">Video Çalışmalarım</div>
        <div class="big-box" onclick="goToImages()">Görsel Çalışmalarım</div>
    </div>
</div>

<div id="videos" class="page-section">
    <div class="back-btn" onclick="goHome()">← Ana Sayfa</div>
    <h1 class="section-title">Video Çalışmalarım</h1>
    <div class="grid-layout video-grid">
        <div class="item-wrapper video-item" onclick="openVideoModal('1144689325','16:9')"><img src="images/kuma-evetmihayirmi.jpg"    class="main-thumbnail"></div>
        <div class="item-wrapper video-item" onclick="openVideoModal('1144689168','9:16')"><img src="images/hilaltufek.jpg"           class="main-thumbnail"></div>
        <div class="item-wrapper video-item" onclick="openVideoModal('1159228579','9:16')"><img src="images/k7-5m.jpg"                class="main-thumbnail"></div>
        <div class="item-wrapper video-item" onclick="openVideoModal('1144689244','16:9')"><img src="images/nesetertas.jpg"           class="main-thumbnail"></div>
        <div class="item-wrapper video-item" onclick="openVideoModal('1144689113','16:9')"><img src="images/gelin-evetmihayirmi1.jpg"  class="main-thumbnail"></div>
        <div class="item-wrapper video-item" onclick="openVideoModal('1144689373','9:16')"><img src="images/teknofest.jpg"            class="main-thumbnail"></div>
        <div class="item-wrapper video-item" onclick="openVideoModal('1144689290','9:16')"><img src="images/setinenleri.jpg"          class="main-thumbnail"></div>
        <div class="item-wrapper video-item" onclick="openVideoModal('1144689403','9:16')"><img src="images/omubumu.jpg"              class="main-thumbnail"></div>
        <div class="item-wrapper video-item" onclick="openVideoModal('1144689001','9:16')"><img src="images/ayvazsef.jpg"             class="main-thumbnail"></div>
        <div class="item-wrapper video-item" onclick="openVideoModal('1144689354','16:9')"><img src="images/fanus.jpg"               class="main-thumbnail"></div>
    </div>
    <div style="max-width:1400px;margin:60px auto 0;padding:0 20px;">
        <h2 style="font-size:24px;opacity:0.9;margin-bottom:30px;">Program Ekran Görüntüleri</h2>
        <div class="screenshot-grid">
            <div class="screenshot-item" onclick="openImageModal('images/sırtsırtaproje.png')"><img src="images/sırtsırtaproje.png"></div>
            <div class="screenshot-item" onclick="openImageModal('images/teknofestproje.png')"><img src="images/teknofestproje.png"></div>
        </div>
    </div>
</div>

<div id="images" class="page-section">
    <div class="back-btn" onclick="goHome()">← Ana Sayfa</div>
    <h1 class="section-title">Görsel Çalışmalarım</h1>
    <div class="grid-layout image-grid" id="dynamic-image-grid"></div>
</div>

<script>
/* ── Grid ─────────────────────────────────────────── */
const imageGrid = document.getElementById('dynamic-image-grid');
for (let i = 1; i <= 25; i++) {
    const item = document.createElement('div');
    item.className = 'item-wrapper image-item';
    item.onclick   = () => openImageModal(`images/thumbnails/${i}.jpg`);
    item.innerHTML = `<img src="images/thumbnails/${i}.jpg" class="main-thumbnail"
        onerror="this.src='https://via.placeholder.com/1600x900?text=Görsel+${i}'">`;
    imageGrid.appendChild(item);
}

/* ── Modal / Nav ──────────────────────────────────── */
const modal            = document.getElementById('content-modal');
const contentContainer = document.getElementById('modal-content-container');
function openVideoModal(id, ratio) {
    const s = ratio === '9:16' ? 'aspect-ratio:9/16;width:400px;' : 'aspect-ratio:16/9;width:1000px;';
    contentContainer.innerHTML = `<iframe src="https://player.vimeo.com/video/${id}?autoplay=1"
        style="${s}" frameborder="0" allow="autoplay;fullscreen" allowfullscreen></iframe>`;
    modal.style.display = 'flex'; document.body.style.overflow = 'hidden';
}
function openImageModal(src) {
    contentContainer.innerHTML = `<img src="${src}">`;
    modal.style.display = 'flex'; document.body.style.overflow = 'hidden';
}
function closeModal()  { modal.style.display = 'none'; contentContainer.innerHTML = ''; document.body.style.overflow = 'auto'; }
function goToVideos()  { document.getElementById('home').classList.add('slide-out-right'); document.getElementById('videos').classList.add('active'); }
function goToImages()  { document.getElementById('home').classList.add('slide-out-left');  document.getElementById('images').classList.add('active'); }
function goHome()      { document.querySelectorAll('.page-section').forEach(s => s.classList.remove('active','slide-out-right','slide-out-left')); }



/* ════════════════════════════════════════════════════════════════
   CANVAS SİSTEMİ  v4
   ─────────────────────────────────────────────────────────────
   • Yıldızlar merkezdEN dışa doğru yavaşça akar (warp/uzay efekti)
   • Sol/sağ yıldızların bir kısmı hover'da ikon şekline morphlar
   • Morphlayan yıldızlar kendi renklerini korur (mavi değil beyaz)
   • Arka planda yeterli yıldız kalır (ikona sadece ~1/3'ü gider)
   • Rounded rect köşe hatası düzeltildi (doğru parametrik yöntem)
═══════════════════════════════════════════════════════════════ */
const canvas = document.getElementById('bg-canvas');
const ctx    = canvas.getContext('2d');

const mouse = { x: -9999, y: -9999 };
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

/* ═══════════════════════════════════════════════════
   İKON NOKTA ÜRETİCİLER — düzeltilmiş rounded rect
═══════════════════════════════════════════════════ */

/* Doğru parametrik rounded rect: köşe yayları düzgün */
function sampleRoundedRect(cx, cy, w, h, r, count) {
    const L = cx-w/2, R = cx+w/2, T = cy-h/2, B = cy+h/2;
    const arcL = (Math.PI/2) * r;
    const sw = w - 2*r, sh = h - 2*r;

    const segs = [
        { len:sw,   fn: t => [L+r+t*sw,  T] },                                           // üst
        { len:arcL, fn: t => { const a=-Math.PI/2+t*Math.PI/2; return [R-r+Math.cos(a)*r, T+r+Math.sin(a)*r]; } }, // sağ üst
        { len:sh,   fn: t => [R, T+r+t*sh] },                                            // sağ
        { len:arcL, fn: t => { const a=t*Math.PI/2;             return [R-r+Math.cos(a)*r, B-r+Math.sin(a)*r]; } }, // sağ alt
        { len:sw,   fn: t => [R-r-t*sw,  B] },                                           // alt
        { len:arcL, fn: t => { const a=Math.PI/2+t*Math.PI/2;   return [L+r+Math.cos(a)*r, B-r+Math.sin(a)*r]; } }, // sol alt
        { len:sh,   fn: t => [L, B-r-t*sh] },                                            // sol
        { len:arcL, fn: t => { const a=Math.PI+t*Math.PI/2;     return [L+r+Math.cos(a)*r, T+r+Math.sin(a)*r]; } }, // sol üst
    ];

    const total = segs.reduce((s,g)=>s+g.len, 0);
    const step  = total / count;
    const pts   = [];
    let carry   = step * 0.5;

    for (const seg of segs) {
        let pos = carry;
        while (pos <= seg.len) {
            pts.push(seg.fn(pos / seg.len));
            pos += step;
        }
        carry = pos - seg.len;
    }
    return pts.slice(0, count);
}

function sampleTriangle(x1,y1, x2,y2, x3,y3, count) {
    const sides = [[x1,y1,x2,y2],[x2,y2,x3,y3],[x3,y3,x1,y1]];
    const lens  = sides.map(([ax,ay,bx,by])=>Math.hypot(bx-ax,by-ay));
    const total = lens.reduce((a,b)=>a+b,0);
    const pts   = [];
    sides.forEach(([ax,ay,bx,by],i)=>{
        const n = Math.round(count*lens[i]/total);
        for(let j=0;j<n;j++){const t=j/n; pts.push([ax+(bx-ax)*t, ay+(by-ay)*t]);}
    });
    return pts;
}

function sampleCircle(cx,cy,r,count) {
    return Array.from({length:count},(_,i)=>{
        const a=(i/count)*Math.PI*2;
        return [cx+Math.cos(a)*r, cy+Math.sin(a)*r];
    });
}

function sampleMountains(cx,cy,w,h,count) {
    const base=cy+h*0.35;
    const path=[[cx-w*0.45,base],[cx-w*0.18,cy-h*0.2],[cx+w*0.02,base],[cx+w*0.2,cy-h*0.38],[cx+w*0.45,base]];
    const lens=path.map((_,i)=>i===0?0:Math.hypot(path[i][0]-path[i-1][0],path[i][1]-path[i-1][1]));
    const total=lens.reduce((a,b)=>a+b,0);
    const step=total/count; const pts=[]; let dist=step/2;
    for(let i=1;i<path.length;i++){
        const[ax,ay]=path[i-1],[bx,by]=path[i];
        const sLen=Math.hypot(bx-ax,by-ay); let pos=0;
        while(pos+dist<=sLen){pos+=dist;const t=pos/sLen;pts.push([ax+(bx-ax)*t,ay+(by-ay)*t]);dist=step;}
        dist-=(sLen-pos);
    }
    return pts.slice(0,count);
}

function buildIconPoints(W,H) {

    /* ══════════════════════════════════════════════════════
       SOL — Büyük yuvarlak köşeli ">" şeridi (chevron)
       Taslak: ekranın sol yarısında, dikey merkezde,
       ucun sağa baktığı, kolların sola ve ekran dışına
       uzandığı içi boş ok şekli.
    ══════════════════════════════════════════════════════ */
    const tipX  = W * 0.24;          // ucun X konumu
    const tipY  = H * 0.50;          // ucun Y (ekran ortası)
    const armH  = H * 0.42;          // kolun dikey uzunluğu
    const thick = Math.min(W,H)*0.045; // şerit kalınlığı
    const cr    = Math.min(W,H)*0.045; // köşe yuvarlaklığı

    // Dış kontur noktaları (saat yönünde):
    // Uç → üst kol → sol üst → sol alt → alt kol → uç (iç)
    const outerTipX = tipX + thick * 0.5;
    const innerTipX = tipX - thick * 0.5;

    // Dış şevron path — samplePath ile örneklenecek
    function sampleChevron(count) {
        const pts = [];
        // Dış kenar: üst kol dışı (sol→sağ), uç dışı, alt kol dışı (sağ→sol)
        // İç kenar: alt kol içi (sol→sağ), iç uç, üst kol içi (sağ→sol)

        // Dış üst kol: (-offscreen, tipY-armH) → (tipX, tipY)
        // Uç dışı: yuvarlak
        // Dış alt kol: (tipX, tipY) → (-offscreen, tipY+armH)

        const offX = -W * 0.06;  // ekran dışı başlangıç

        // Üst dış kenar (sol→sağ yukarı eğimli)
        const topStartX = offX, topStartY = tipY - armH;
        // İç üst kenar (sol→sağ yukarı eğimli, thick kadar aşağıda)
        const topInX = offX, topInY = tipY - armH + thick;

        const n4 = Math.floor(count * 0.20); // her kol için
        const nTip = Math.floor(count * 0.12);
        const nFlat = Math.floor(count * 0.04);

        // Dış üst kol
        for(let i=0;i<n4;i++){
            const t=i/n4;
            pts.push([topStartX+(tipX-topStartX)*t, topStartY+(tipY-armH*0.15-topStartY)*t]);
        }
        // Dış uç yayı (üstten alta döner)
        for(let i=0;i<=nTip;i++){
            const t=i/nTip;
            const a = -Math.PI*0.55 + t*Math.PI*1.1;
            pts.push([tipX + thick*0.6*Math.cos(a)*0.6, tipY + thick*0.85*Math.sin(a)]);
        }
        // Dış alt kol
        for(let i=0;i<n4;i++){
            const t=i/n4;
            pts.push([tipX-(tipX-topStartX)*t, (tipY+armH*0.15)+(topStartY+armH*2-tipY-armH*0.15)*t]);
        }
        // Sol alt düz kenar (ekran dışında — birkaç nokta)
        for(let i=0;i<nFlat;i++){
            const t=i/nFlat;
            pts.push([offX, tipY+armH - t*thick]);
        }
        // İç alt kol (sağdan sola)
        for(let i=0;i<n4;i++){
            const t=i/n4;
            pts.push([offX+(tipX-thick*0.8-offX)*t, tipY+armH-thick+(-(armH-thick)*t)]);
        }
        // İç uç yayı
        for(let i=0;i<=nTip;i++){
            const t=i/nTip;
            const a = Math.PI*0.55 - t*Math.PI*1.1;
            pts.push([tipX-thick*0.9 + thick*0.3*Math.cos(a)*0.6, tipY + thick*0.7*Math.sin(a)]);
        }
        // İç üst kol (soldan sağa geri)
        for(let i=0;i<n4;i++){
            const t=i/n4;
            pts.push([tipX-thick*0.8-(tipX-thick*0.8-offX)*t, tipY-armH+thick+(armH-thick)*t]);
        }
        // Sol üst düz kenar
        for(let i=0;i<nFlat;i++){
            const t=i/nFlat;
            pts.push([offX, tipY-armH+thick*t]);
        }
        return pts;
    }

    const vPts = sampleChevron(480);

    /* ══════════════════════════════════════════════════════
       SAĞ — Manzara fotoğrafı ikonu
       Taslak: sağda dağ silüeti + üst sağda çember (güneş/kafa)
       Konumlar ekranın sağ yarısında, kısmen dışarıda.
    ══════════════════════════════════════════════════════ */
    const S   = Math.min(W,H);
    const rcx = W * 0.78;  // sağ grup merkezi X
    const rcy = H * 0.50;

    // Dağlar: büyük iki tepe, geniş
    const mW = S * 0.38, mH = S * 0.42;
    const mBase = rcy + mH * 0.28;

    function sampleLandscape(count) {
        const pts = [];
        // İki dağ tepesi path
        const path = [
            [rcx - mW*0.50, mBase],          // sol dip
            [rcx - mW*0.10, rcy - mH*0.10],  // sol tepe
            [rcx + mW*0.10, mBase - mH*0.05],// iki tepe arası vadi
            [rcx + mW*0.42, rcy - mH*0.38],  // sağ tepe (daha yüksek)
            [rcx + mW*0.72, mBase],           // sağ dip (ekran dışına uzanır)
        ];
        const lens = path.map((_,i)=>i===0?0:Math.hypot(path[i][0]-path[i-1][0],path[i][1]-path[i-1][1]));
        const total = lens.reduce((a,b)=>a+b,0);
        const step  = total/count;
        let dist=step/2;
        for(let i=1;i<path.length;i++){
            const[ax,ay]=path[i-1],[bx,by]=path[i];
            const sLen=Math.hypot(bx-ax,by-ay);
            let pos=0;
            while(pos+dist<=sLen){pos+=dist;const t=pos/sLen;pts.push([ax+(bx-ax)*t,ay+(by-ay)*t]);dist=step;}
            dist-=(sLen-pos);
        }
        return pts;
    }

    // Çember (baş/güneş): sağ üstte
    const circR  = S * 0.090;
    const circCx = rcx + mW * 0.28;
    const circCy = rcy - mH * 0.42;
    const circPts= sampleCircle(circCx, circCy, circR, 180);

    const landPts = sampleLandscape(300);

    const iPts = [...circPts, ...landPts];

    return {vPts, iPts};
}

/* ═══════════════════════════════════════════════════
   STAR — warp hareketi + isteğe bağlı morph
═══════════════════════════════════════════════════ */
class Star {
    constructor(side) {
        this.side       = side;   // 'left'|'right'|'none'
        this.morphTarget= null;
        this.progress   = 0;
        this.phase      = Math.random()*Math.PI*2;
        this.twinkleSpeed = Math.random()*0.010+0.003;
        this.twinkleAmp   = Math.random()*0.35+0.10;
        const cr=Math.random();
        this.color = cr<0.76?'255,255,255':cr<0.90?'210,228,255':'255,248,215';
        this.initWarp();
    }

    initWarp(fromCenter=false) {
        const W=canvas.width, H=canvas.height;
        const cx=W/2, cy=H/2;
        const maxD=Math.hypot(W,H)*0.65;

        /* Açıyı yıldızın tarafına göre kısıtla */
        if (this.side === 'left') {
            // Sol yarı: π/2 … 3π/2 (sol yönler)
            this.warpAngle = Math.PI*0.5 + Math.random()*Math.PI;
        } else if (this.side === 'right') {
            // Sağ yarı: -π/2 … π/2 (sağ yönler)
            this.warpAngle = -Math.PI*0.5 + Math.random()*Math.PI;
        } else {
            // Merkez şerit: tam orta band
            this.warpAngle = Math.random()*Math.PI*2;
        }

        this.warpDist  = fromCenter
            ? Math.random()*40
            : Math.random()*maxD;
        this.warpSpeed = Math.random()*0.22+0.04;

        this._updateWarpPos(cx,cy,maxD);
        this.homeX=this.x; this.homeY=this.y;
    }

    _updateWarpPos(cx,cy,maxD) {
        const W=canvas.width, H=canvas.height;
        const ratio=Math.min(1, this.warpDist/maxD);
        this.homeX = cx+Math.cos(this.warpAngle)*this.warpDist;
        this.homeY = cy+Math.sin(this.warpAngle)*this.warpDist;
        this.baseR  = 0.15+ratio*1.4;
        this.baseLum= 0.04+ratio*0.58;
    }

    update(t, hoverProgress) {
        const W=canvas.width, H=canvas.height;
        const cx=W/2, cy=H/2;
        const maxD=Math.hypot(W,H)*0.65;

        /* ── Warp: merkezdEN dışa ── */
        this.warpDist += this.warpSpeed;
        if (this.warpDist > maxD) this.initWarp(true);
        else this._updateWarpPos(cx,cy,maxD);

        /* ── Morph lerp ── */
        const tgt = (this.morphTarget && hoverProgress>0) ? hoverProgress : 0;
        this.progress += (tgt - this.progress) * 0.07;

        if (this.morphTarget && this.progress > 0.002) {
            this.x = this.homeX + this.progress*(this.morphTarget[0]-this.homeX);
            this.y = this.homeY + this.progress*(this.morphTarget[1]-this.homeY);
        } else {
            this.x = this.homeX; this.y = this.homeY;
        }

        /* ── Parlaklık & boyut ── */
        const flicker=Math.sin(t*this.twinkleSpeed+this.phase)*this.twinkleAmp;
        const p=this.progress;

        this.lum = Math.max(0.04, this.baseLum+flicker*(1-p*0.6));
        this.r   = this.baseR*(1+p*0.3);

        /* Fare yakınlığı (sadece home modunda, düşük progress) */
        if (p < 0.3) {
            const dx=this.x-mouse.x, dy=this.y-mouse.y;
            const dist=Math.sqrt(dx*dx+dy*dy);
            if (dist<180) {
                const prx=1-dist/180;
                this.lum=Math.min(1,this.lum+prx*0.75);
                this.r  =this.baseR*(1+prx*3.5);
            }
        }
    }

    draw() {
        const p = this.progress;

        /* ── Glow miktarı p arttıkça sıfıra iner, azaldıkça geri gelir ──
           Bu sayede morph↔home geçişinde ani parlama olmaz.           */
        const glowFade = Math.max(0, 1 - p * 6);   // p>0.17'de glow=0

        /* Nokta boyutu ve parlaklığı: her iki modda tutarlı */
        const dotR   = Math.max(0.4, this.r);
        const dotAlp = Math.min(1, this.lum * (1.2 + p * 0.4));

        ctx.beginPath();
        ctx.arc(this.x, this.y, dotR, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${this.color},${dotAlp})`;
        ctx.fill();

        /* Glow halo — yalnızca home moduna yakınken, smooth fade */
        if (glowFade > 0.01) {
            const gR = dotR * 8;
            const g  = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, gR);
            g.addColorStop(0,   `rgba(${this.color},${this.lum * 0.5  * glowFade})`);
            g.addColorStop(0.4, `rgba(${this.color},${this.lum * 0.10 * glowFade})`);
            g.addColorStop(1,   `rgba(${this.color},0)`);
            ctx.beginPath();
            ctx.arc(this.x, this.y, gR, 0, Math.PI * 2);
            ctx.fillStyle = g;
            ctx.fill();
        }
    }
}

/* ═══════════════════════════════════════════════════
   KAYAN YILDIZ
═══════════════════════════════════════════════════ */
class ShootingStar {
    constructor() {
        const e=Math.floor(Math.random()*4);
        if(e===0){this.x=Math.random()*canvas.width;this.y=-10;}
        else if(e===1){this.x=canvas.width+10;this.y=Math.random()*canvas.height;}
        else if(e===2){this.x=Math.random()*canvas.width;this.y=canvas.height+10;}
        else{this.x=-10;this.y=Math.random()*canvas.height;}
        const a=Math.atan2(canvas.height/2-this.y,canvas.width/2-this.x)+(Math.random()-0.5)*0.8;
        this.speed=Math.random()*6+3;
        this.vx=Math.cos(a)*this.speed; this.vy=Math.sin(a)*this.speed;
        this.len=Math.random()*200+80; this.width=Math.random()*1+0.3;
        this.alpha=0; this.state='in'; this.life=0; this.maxLife=Math.random()*55+30;
    }
    update(){
        this.x+=this.vx;this.y+=this.vy;this.life++;
        if(this.state==='in'){this.alpha+=0.08;if(this.alpha>=0.9){this.alpha=0.9;this.state='on';}}
        if(this.state==='on'&&this.life>this.maxLife)this.state='out';
        if(this.state==='out'){this.alpha-=0.03;if(this.alpha<=0){this.alpha=0;this.state='dead';}}
    }
    get isDead(){return this.state==='dead';}
    draw(){
        if(this.alpha<=0)return;
        const tx=this.x-(this.vx/this.speed)*this.len,ty=this.y-(this.vy/this.speed)*this.len;
        const g=ctx.createLinearGradient(tx,ty,this.x,this.y);
        g.addColorStop(0,'rgba(255,255,255,0)');
        g.addColorStop(0.55,`rgba(200,215,255,${this.alpha*0.25})`);
        g.addColorStop(1,`rgba(255,255,255,${this.alpha})`);
        ctx.beginPath();ctx.moveTo(tx,ty);ctx.lineTo(this.x,this.y);
        ctx.strokeStyle=g;ctx.lineWidth=this.width;ctx.lineCap='round';ctx.stroke();
        const hg=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,7);
        hg.addColorStop(0,`rgba(255,255,255,${this.alpha})`);
        hg.addColorStop(1,'rgba(200,220,255,0)');
        ctx.beginPath();ctx.arc(this.x,this.y,7,0,Math.PI*2);ctx.fillStyle=hg;ctx.fill();
    }
}

/* ════════════════════════════
   ANA DÖNGÜ
════════════════════════════ */
let stars=[], shootingStars=[];
let t=0, shootTimer=240;
let leftHover=0, rightHover=0;

function init() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    const {vPts,iPts} = buildIconPoints(canvas.width, canvas.height);

    /*  Toplam yıldız yoğunluğu.
        Her iki yarı için: ikonPoints kadar morph + 2× kadar bg yıldızı
        → morph sırasında arkaplan %65-70 dolu kalır              */
    const morphPerSide = Math.max(vPts.length, iPts.length);  // ~380
    const bgPerSide    = Math.round(morphPerSide * 2.2);       // ~836
    const centerCount  = Math.round(morphPerSide * 0.8);

    stars=[];

    /* Sol: morph yıldızları */
    for(let i=0;i<morphPerSide;i++){
        const s=new Star('left');
        if(i<vPts.length) s.morphTarget=vPts[i];
        stars.push(s);
    }
    /* Sol: arka plan yıldızları (morph yok) */
    for(let i=0;i<bgPerSide;i++) stars.push(new Star('left'));

    /* Sağ: morph yıldızları */
    for(let i=0;i<morphPerSide;i++){
        const s=new Star('right');
        if(i<iPts.length) s.morphTarget=iPts[i];
        stars.push(s);
    }
    /* Sağ: arka plan yıldızları */
    for(let i=0;i<bgPerSide;i++) stars.push(new Star('right'));

    /* Merkez şerit */
    for(let i=0;i<centerCount;i++) stars.push(new Star('none'));

    shootingStars=[];
}

function animate() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    t++;

    const homeEl=document.getElementById('home');
    const homeVisible=!homeEl.classList.contains('slide-out-right')&&
                      !homeEl.classList.contains('slide-out-left')&&
                      parseFloat(getComputedStyle(homeEl).opacity)>0.1;

    if(homeVisible){
        const inL=mouse.x>0&&mouse.x<canvas.width/2&&mouse.y>0&&mouse.y<canvas.height;
        const inR=mouse.x>=canvas.width/2&&mouse.x<canvas.width&&mouse.y>0&&mouse.y<canvas.height;
        leftHover +=((inL?1:0)-leftHover)*0.06;
        rightHover+=((inR?1:0)-rightHover)*0.06;
    } else {
        leftHover +=(0-leftHover)*0.10;
        rightHover+=(0-rightHover)*0.10;
    }

    stars.forEach(s=>{
        const hp=s.side==='left'?leftHover:s.side==='right'?rightHover:0;
        s.update(t,hp); s.draw();
    });

    if(--shootTimer<=0){
        shootingStars.push(new ShootingStar());
        if(Math.random()<0.2)setTimeout(()=>shootingStars.push(new ShootingStar()),800);
        shootTimer=Math.floor(Math.random()*300+200);
    }
    shootingStars.forEach(s=>{s.update();s.draw();});
    shootingStars=shootingStars.filter(s=>!s.isDead);

    requestAnimationFrame(animate);
}

window.addEventListener('resize',init);
init();
animate();
</script>
</body>
</html>
